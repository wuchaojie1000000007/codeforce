A - Sign Flipping

fun main() {
    repeat(readLine()!!.toInt()) {
        val size = readLine()!!.toInt()
        val list = readLine()!!.split(" ").map { it.toInt() }.toMutableList()
        for (i in 0..size - 1) {
            when (i % 2) {
                0 -> if (list[i] > 0)
                    list[i] = list[i] * (-1)
                1 -> if (list[i] <0)
                    list[i] = list[i] * (-1)
            }
        }
        println(list.joinToString(" "))
    }
}

accepted


B - Neighbor Grid

fun main() {
    repeat(readLine()!!.toInt()) {
        val (row, column) = readLine()!!.split(" ").map { it.toInt() }
        var answer = "YES"

        val firstLine = readLine()!!.split(" ").map { it.toInt() }
        if (firstLine.any { it>3 })
            answer = "No"
        if (firstLine[0]>2 || firstLine[column-1]>2)
            answer = "NO"

        repeat(row-2) {
            val line = readLine()!!.split(" ").map { it.toInt() }
            if (line.any { it>4 })
                answer = "No"
            if (line[0]>3 || line[column-1]>3)
                answer = "NO"
        }

        val lastLine = readLine()!!.split(" ").map { it.toInt() }
        if (lastLine.any { it>3 })
            answer = "No"
        if (lastLine[0]>2 || lastLine[column-1]>2)
            answer = "NO"

        println(answer)
        if (answer == "YES") {
            val max = MutableList(column) {3}

            max[0] -= 1
            max[column-1] -= 1
            println(max.joinToString(" "))

            for (index in max.indices) {
                max[index] += 1
            }
            repeat(row-2) {
                println(max.joinToString(" "))
            }

            for (index in max.indices) {
                max[index] -= 1
            }
            println(max.joinToString(" "))
        }
    }
}

Accepted


C - Element Extermination

fun main() {
    repeat(readLine()!!.toInt()) {
        val size = readLine()!!.toInt()
        val list = readLine()!!.split(" ").map { it.toInt() }
        println(if (list[0]<list[size-1]) "YES" else "NO")
    }
}

Accepted


D - Replace by MEX

fun main() {
    repeat(readLine()!!.toInt()) {
        val size = readLine()!!.toInt()
        val list = readLine()!!.split(" ").map { it.toInt() }.toMutableList()
        val unfixedPoint = MutableList(size) { it }
        val operation = mutableListOf<Int>()

        //println(list)

        while (!unfixedPoint.isEmpty()) {
            val mex = findMEX(list)
            if (mex == size) {
                val index = list[unfixedPoint[0]]

                // Then index become mex
                list[unfixedPoint[0]] = size
                operation += unfixedPoint[0]

                //println(list)

                // Put index in the right place
                list[index] = index
                operation += index

                unfixedPoint -= index
            } else {
                list[mex] = mex
                operation += mex
                unfixedPoint -= mex
            }
            //println(list)
        }
        println(operation.size)
        for (i in 0..operation.size-1){
            operation[i] += 1
        }
        println(operation.joinToString(" "))
        //println(list)
    }
}

fun findMEX(list: List<Int>): Int {
    val size = list.size
    val newList = MutableList(size + 1) { it }
    for (item in list) {
        val index = newList.binarySearch(item)
        //println(index)
        if (index >-1)
            newList.removeAt(index)
    }
    return newList[0]
}

Accepted


E - Inversion SwapSort

fun main() {
    val size = readLine()!!.toInt()
    val list = readLine()!!.split(" ").map { it.toInt() }.toMutableList()
    val operation = mutableListOf<Pair<Int, Int>>()

    repeat(size - 1) {
        var index = it + 1
        while (index > 0 && list[index] < list[index - 1]) {
            list[index] = list[index - 1].also { list[index - 1] = list[index] }
            operation += Pair(index - 1, index)
            index -= 1
        }
    }
    println(operation.size)
    for (item in operation) {
        println("${item.first + 1} ${item.second + 1}")
    }
    //println(list)
}

Wrong answer on test 1
